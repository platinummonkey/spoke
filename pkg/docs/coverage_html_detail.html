
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/platinummonkey/spoke/pkg/docs/generator.go (0.0%)</option>
				
				<option value="file1">github.com/platinummonkey/spoke/pkg/docs/handlers.go (0.0%)</option>
				
				<option value="file2">github.com/platinummonkey/spoke/pkg/docs/html.go (96.7%)</option>
				
				<option value="file3">github.com/platinummonkey/spoke/pkg/docs/markdown.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package docs

import (
        "fmt"
        "strings"

        "github.com/platinummonkey/spoke/pkg/api/protobuf"
)

// Documentation represents generated documentation for a proto schema
type Documentation struct {
        PackageName string
        Syntax      string
        Description string
        Messages    []*MessageDoc
        Enums       []*EnumDoc
        Services    []*ServiceDoc
        Imports     []string
        Options     map[string]string
}

// MessageDoc represents documentation for a message
type MessageDoc struct {
        Name        string
        FullName    string
        Description string
        Fields      []*FieldDoc
        NestedTypes []*MessageDoc
        Enums       []*EnumDoc
        Deprecated  bool
        Location    string
}

// FieldDoc represents documentation for a field
type FieldDoc struct {
        Name        string
        Number      int
        Type        string
        Label       string
        Description string
        Deprecated  bool
        Required    bool
        Optional    bool
        Repeated    bool
        OneofName   string
}

// EnumDoc represents documentation for an enum
type EnumDoc struct {
        Name        string
        FullName    string
        Description string
        Values      []*EnumValueDoc
        Deprecated  bool
}

// EnumValueDoc represents documentation for an enum value
type EnumValueDoc struct {
        Name        string
        Number      int
        Description string
        Deprecated  bool
}

// ServiceDoc represents documentation for a service
type ServiceDoc struct {
        Name        string
        Description string
        Methods     []*MethodDoc
        Deprecated  bool
}

// MethodDoc represents documentation for a service method
type MethodDoc struct {
        Name              string
        Description       string
        RequestType       string
        ResponseType      string
        ClientStreaming   bool
        ServerStreaming   bool
        Deprecated        bool
        HTTPMethod        string
        HTTPPath          string
}

// Generator generates documentation from proto AST
type Generator struct{}

// NewGenerator creates a new documentation generator
func NewGenerator() *Generator <span class="cov0" title="0">{
        return &amp;Generator{}
}</span>

// Generate generates documentation from a proto AST
func (g *Generator) Generate(ast *protobuf.RootNode) (*Documentation, error) <span class="cov0" title="0">{
        doc := &amp;Documentation{
                Messages: make([]*MessageDoc, 0),
                Enums:    make([]*EnumDoc, 0),
                Services: make([]*ServiceDoc, 0),
                Imports:  make([]string, 0),
                Options:  make(map[string]string),
        }

        // Extract syntax
        if ast.Syntax != nil </span><span class="cov0" title="0">{
                doc.Syntax = ast.Syntax.Value
        }</span>

        // Extract package
        <span class="cov0" title="0">if ast.Package != nil </span><span class="cov0" title="0">{
                doc.PackageName = ast.Package.Name
        }</span>

        // Extract imports
        <span class="cov0" title="0">for _, imp := range ast.Imports </span><span class="cov0" title="0">{
                doc.Imports = append(doc.Imports, imp.Path)
        }</span>

        // Extract messages
        <span class="cov0" title="0">for _, msg := range ast.Messages </span><span class="cov0" title="0">{
                messageDoc := g.generateMessageDoc(msg, doc.PackageName)
                doc.Messages = append(doc.Messages, messageDoc)
        }</span>

        // Extract enums
        <span class="cov0" title="0">for _, enum := range ast.Enums </span><span class="cov0" title="0">{
                enumDoc := g.generateEnumDoc(enum, doc.PackageName)
                doc.Enums = append(doc.Enums, enumDoc)
        }</span>

        // Extract services
        <span class="cov0" title="0">for _, svc := range ast.Services </span><span class="cov0" title="0">{
                serviceDoc := g.generateServiceDoc(svc)
                doc.Services = append(doc.Services, serviceDoc)
        }</span>

        <span class="cov0" title="0">return doc, nil</span>
}

// generateMessageDoc generates documentation for a message
func (g *Generator) generateMessageDoc(msg *protobuf.MessageNode, packageName string) *MessageDoc <span class="cov0" title="0">{
        doc := &amp;MessageDoc{
                Name:        msg.Name,
                FullName:    fmt.Sprintf("%s.%s", packageName, msg.Name),
                Description: extractComments(msg.Comments),
                Fields:      make([]*FieldDoc, 0),
                NestedTypes: make([]*MessageDoc, 0),
                Enums:       make([]*EnumDoc, 0),
                Location:    fmt.Sprintf("%s.%s", packageName, msg.Name),
        }

        // Extract fields
        for _, field := range msg.Fields </span><span class="cov0" title="0">{
                fieldDoc := g.generateFieldDoc(field)
                doc.Fields = append(doc.Fields, fieldDoc)
        }</span>

        // Extract nested messages
        <span class="cov0" title="0">for _, nested := range msg.Nested </span><span class="cov0" title="0">{
                nestedDoc := g.generateMessageDoc(nested, doc.FullName)
                doc.NestedTypes = append(doc.NestedTypes, nestedDoc)
        }</span>

        // Extract nested enums
        <span class="cov0" title="0">for _, enum := range msg.Enums </span><span class="cov0" title="0">{
                enumDoc := g.generateEnumDoc(enum, doc.FullName)
                doc.Enums = append(doc.Enums, enumDoc)
        }</span>

        <span class="cov0" title="0">return doc</span>
}

// generateFieldDoc generates documentation for a field
func (g *Generator) generateFieldDoc(field *protobuf.FieldNode) *FieldDoc <span class="cov0" title="0">{
        doc := &amp;FieldDoc{
                Name:        field.Name,
                Number:      field.Number,
                Type:        field.Type,
                Description: extractComments(field.Comments),
        }

        // Determine field label
        if field.Repeated </span><span class="cov0" title="0">{
                doc.Label = "repeated"
                doc.Repeated = true
        }</span> else<span class="cov0" title="0"> if field.Optional </span><span class="cov0" title="0">{
                doc.Label = "optional"
                doc.Optional = true
        }</span> else<span class="cov0" title="0"> if field.Required </span><span class="cov0" title="0">{
                doc.Label = "required"
                doc.Required = true
        }</span>

        <span class="cov0" title="0">return doc</span>
}

// generateEnumDoc generates documentation for an enum
func (g *Generator) generateEnumDoc(enum *protobuf.EnumNode, packageName string) *EnumDoc <span class="cov0" title="0">{
        doc := &amp;EnumDoc{
                Name:        enum.Name,
                FullName:    fmt.Sprintf("%s.%s", packageName, enum.Name),
                Description: extractComments(enum.Comments),
                Values:      make([]*EnumValueDoc, 0),
        }

        for _, value := range enum.Values </span><span class="cov0" title="0">{
                valueDoc := &amp;EnumValueDoc{
                        Name:        value.Name,
                        Number:      value.Number,
                        Description: extractComments(value.Comments),
                }
                doc.Values = append(doc.Values, valueDoc)
        }</span>

        <span class="cov0" title="0">return doc</span>
}

// generateServiceDoc generates documentation for a service
func (g *Generator) generateServiceDoc(svc *protobuf.ServiceNode) *ServiceDoc <span class="cov0" title="0">{
        doc := &amp;ServiceDoc{
                Name:        svc.Name,
                Description: extractComments(svc.Comments),
                Methods:     make([]*MethodDoc, 0),
        }

        for _, rpc := range svc.RPCs </span><span class="cov0" title="0">{
                methodDoc := &amp;MethodDoc{
                        Name:            rpc.Name,
                        Description:     extractComments(rpc.Comments),
                        RequestType:     rpc.InputType,
                        ResponseType:    rpc.OutputType,
                        ClientStreaming: rpc.ClientStreaming,
                        ServerStreaming: rpc.ServerStreaming,
                }

                // Extract HTTP annotations if present
                // This would parse google.api.http options
                // For now, we'll leave these empty

                doc.Methods = append(doc.Methods, methodDoc)
        }</span>

        <span class="cov0" title="0">return doc</span>
}

// extractComments extracts and formats comments
func extractComments(comments []*protobuf.CommentNode) string <span class="cov0" title="0">{
        if len(comments) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var lines []string
        for _, comment := range comments </span><span class="cov0" title="0">{
                text := strings.TrimSpace(comment.Text)
                // Remove leading comment markers
                text = strings.TrimPrefix(text, "//")
                text = strings.TrimPrefix(text, "/*")
                text = strings.TrimSuffix(text, "*/")
                text = strings.TrimSpace(text)
                if text != "" </span><span class="cov0" title="0">{
                        lines = append(lines, text)
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// Summary returns a summary of the documentation
func (d *Documentation) Summary() string <span class="cov0" title="0">{
        return fmt.Sprintf("Package: %s, Messages: %d, Enums: %d, Services: %d",
                d.PackageName, len(d.Messages), len(d.Enums), len(d.Services))
}</span>

// FindMessage finds a message by name
func (d *Documentation) FindMessage(name string) *MessageDoc <span class="cov0" title="0">{
        for _, msg := range d.Messages </span><span class="cov0" title="0">{
                if msg.Name == name || msg.FullName == name </span><span class="cov0" title="0">{
                        return msg
                }</span>
                // Check nested messages
                <span class="cov0" title="0">if nested := findNestedMessage(msg, name); nested != nil </span><span class="cov0" title="0">{
                        return nested
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// findNestedMessage recursively finds a nested message
func findNestedMessage(msg *MessageDoc, name string) *MessageDoc <span class="cov0" title="0">{
        for _, nested := range msg.NestedTypes </span><span class="cov0" title="0">{
                if nested.Name == name || nested.FullName == name </span><span class="cov0" title="0">{
                        return nested
                }</span>
                <span class="cov0" title="0">if found := findNestedMessage(nested, name); found != nil </span><span class="cov0" title="0">{
                        return found
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindEnum finds an enum by name
func (d *Documentation) FindEnum(name string) *EnumDoc <span class="cov0" title="0">{
        for _, enum := range d.Enums </span><span class="cov0" title="0">{
                if enum.Name == name || enum.FullName == name </span><span class="cov0" title="0">{
                        return enum
                }</span>
        }
        // Check nested enums
        <span class="cov0" title="0">for _, msg := range d.Messages </span><span class="cov0" title="0">{
                if enum := findNestedEnum(msg, name); enum != nil </span><span class="cov0" title="0">{
                        return enum
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// findNestedEnum recursively finds a nested enum
func findNestedEnum(msg *MessageDoc, name string) *EnumDoc <span class="cov0" title="0">{
        for _, enum := range msg.Enums </span><span class="cov0" title="0">{
                if enum.Name == name || enum.FullName == name </span><span class="cov0" title="0">{
                        return enum
                }</span>
        }
        <span class="cov0" title="0">for _, nested := range msg.NestedTypes </span><span class="cov0" title="0">{
                if enum := findNestedEnum(nested, name); enum != nil </span><span class="cov0" title="0">{
                        return enum
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindService finds a service by name
func (d *Documentation) FindService(name string) *ServiceDoc <span class="cov0" title="0">{
        for _, svc := range d.Services </span><span class="cov0" title="0">{
                if svc.Name == name </span><span class="cov0" title="0">{
                        return svc
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package docs

import (
        "encoding/json"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/platinummonkey/spoke/pkg/api"
        "github.com/platinummonkey/spoke/pkg/api/protobuf"
)

// DocsHandlers provides HTTP handlers for documentation
type DocsHandlers struct {
        storage        api.Storage
        generator      *Generator
        htmlExporter   *HTMLExporter
        markdownExporter *MarkdownExporter
}

// NewDocsHandlers creates new documentation handlers
func NewDocsHandlers(storage api.Storage) *DocsHandlers <span class="cov0" title="0">{
        return &amp;DocsHandlers{
                storage:        storage,
                generator:      NewGenerator(),
                htmlExporter:   NewHTMLExporter(),
                markdownExporter: NewMarkdownExporter(),
        }
}</span>

// RegisterRoutes registers documentation routes
func (h *DocsHandlers) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        // Get documentation for a specific version
        router.HandleFunc("/docs/{module}/{version}", h.getVersionDocs).Methods("GET")
        router.HandleFunc("/docs/{module}/{version}/markdown", h.getVersionDocsMarkdown).Methods("GET")
        router.HandleFunc("/docs/{module}/{version}/json", h.getVersionDocsJSON).Methods("GET")

        // Compare versions
        router.HandleFunc("/docs/{module}/compare", h.compareVersions).Methods("GET")
}</span>

// getVersionDocs handles GET /docs/{module}/{version}
func (h *DocsHandlers) getVersionDocs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        moduleName := vars["module"]
        version := vars["version"]

        // Get version from storage
        ver, err := h.storage.GetVersion(moduleName, version)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "version not found: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if len(ver.Files) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "no proto files in version", http.StatusNotFound)
                return
        }</span>

        // Parse proto file
        <span class="cov0" title="0">parser := protobuf.NewStringParser(ver.Files[0].Content)
        ast, err := parser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to parse proto: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Generate documentation
        <span class="cov0" title="0">doc, err := h.generator.Generate(ast)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to generate documentation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Export to HTML
        <span class="cov0" title="0">html, err := h.htmlExporter.ExportWithVersion(doc, version)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to export HTML: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(html))</span>
}

// getVersionDocsMarkdown handles GET /docs/{module}/{version}/markdown
func (h *DocsHandlers) getVersionDocsMarkdown(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        moduleName := vars["module"]
        version := vars["version"]

        // Get version from storage
        ver, err := h.storage.GetVersion(moduleName, version)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "version not found: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if len(ver.Files) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "no proto files in version", http.StatusNotFound)
                return
        }</span>

        // Parse proto file
        <span class="cov0" title="0">parser := protobuf.NewStringParser(ver.Files[0].Content)
        ast, err := parser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to parse proto: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Generate documentation
        <span class="cov0" title="0">doc, err := h.generator.Generate(ast)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to generate documentation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Export to Markdown
        <span class="cov0" title="0">markdown := h.markdownExporter.ExportWithVersion(doc, version)

        w.Header().Set("Content-Type", "text/markdown; charset=utf-8")
        w.Header().Set("Content-Disposition", "attachment; filename="+moduleName+"-"+version+".md")
        w.Write([]byte(markdown))</span>
}

// getVersionDocsJSON handles GET /docs/{module}/{version}/json
func (h *DocsHandlers) getVersionDocsJSON(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        moduleName := vars["module"]
        version := vars["version"]

        // Get version from storage
        ver, err := h.storage.GetVersion(moduleName, version)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "version not found: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if len(ver.Files) == 0 </span><span class="cov0" title="0">{
                http.Error(w, "no proto files in version", http.StatusNotFound)
                return
        }</span>

        // Parse proto file
        <span class="cov0" title="0">parser := protobuf.NewStringParser(ver.Files[0].Content)
        ast, err := parser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to parse proto: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Generate documentation
        <span class="cov0" title="0">doc, err := h.generator.Generate(ast)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to generate documentation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(doc)</span>
}

// compareVersions handles GET /docs/{module}/compare?old={version}&amp;new={version}
func (h *DocsHandlers) compareVersions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        moduleName := vars["module"]

        oldVersion := r.URL.Query().Get("old")
        newVersion := r.URL.Query().Get("new")

        if oldVersion == "" || newVersion == "" </span><span class="cov0" title="0">{
                http.Error(w, "old and new version parameters required", http.StatusBadRequest)
                return
        }</span>

        // Get old version
        <span class="cov0" title="0">oldVer, err := h.storage.GetVersion(moduleName, oldVersion)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "old version not found: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        // Get new version
        <span class="cov0" title="0">newVer, err := h.storage.GetVersion(moduleName, newVersion)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "new version not found: "+err.Error(), http.StatusNotFound)
                return
        }</span>

        // Parse old version
        <span class="cov0" title="0">oldParser := protobuf.NewStringParser(oldVer.Files[0].Content)
        oldAST, err := oldParser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to parse old proto: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Parse new version
        <span class="cov0" title="0">newParser := protobuf.NewStringParser(newVer.Files[0].Content)
        newAST, err := newParser.Parse()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to parse new proto: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Generate documentation for both versions
        <span class="cov0" title="0">oldDoc, err := h.generator.Generate(oldAST)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to generate old documentation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">newDoc, err := h.generator.Generate(newAST)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "failed to generate new documentation: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // Compare documentation
        <span class="cov0" title="0">diff := h.compareDocs(oldDoc, newDoc)

        // Return comparison
        response := map[string]interface{}{
                "old_version": oldVersion,
                "new_version": newVersion,
                "changes":     diff,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// compareDocs compares two documentation objects and returns changes
func (h *DocsHandlers) compareDocs(oldDoc, newDoc *Documentation) map[string]interface{} <span class="cov0" title="0">{
        changes := make(map[string]interface{})

        // Compare messages
        messagesAdded := []string{}
        messagesRemoved := []string{}
        messagesModified := []string{}

        oldMessages := make(map[string]*MessageDoc)
        for _, msg := range oldDoc.Messages </span><span class="cov0" title="0">{
                oldMessages[msg.Name] = msg
        }</span>

        <span class="cov0" title="0">newMessages := make(map[string]*MessageDoc)
        for _, msg := range newDoc.Messages </span><span class="cov0" title="0">{
                newMessages[msg.Name] = msg
        }</span>

        // Find added messages
        <span class="cov0" title="0">for name := range newMessages </span><span class="cov0" title="0">{
                if _, exists := oldMessages[name]; !exists </span><span class="cov0" title="0">{
                        messagesAdded = append(messagesAdded, name)
                }</span>
        }

        // Find removed messages
        <span class="cov0" title="0">for name := range oldMessages </span><span class="cov0" title="0">{
                if _, exists := newMessages[name]; !exists </span><span class="cov0" title="0">{
                        messagesRemoved = append(messagesRemoved, name)
                }</span>
        }

        // Find modified messages (simplified - just check field count)
        <span class="cov0" title="0">for name, newMsg := range newMessages </span><span class="cov0" title="0">{
                if oldMsg, exists := oldMessages[name]; exists </span><span class="cov0" title="0">{
                        if len(oldMsg.Fields) != len(newMsg.Fields) </span><span class="cov0" title="0">{
                                messagesModified = append(messagesModified, name)
                        }</span>
                }
        }

        <span class="cov0" title="0">changes["messages"] = map[string]interface{}{
                "added":    messagesAdded,
                "removed":  messagesRemoved,
                "modified": messagesModified,
        }

        // Compare services
        servicesAdded := []string{}
        servicesRemoved := []string{}

        oldServices := make(map[string]*ServiceDoc)
        for _, svc := range oldDoc.Services </span><span class="cov0" title="0">{
                oldServices[svc.Name] = svc
        }</span>

        <span class="cov0" title="0">newServices := make(map[string]*ServiceDoc)
        for _, svc := range newDoc.Services </span><span class="cov0" title="0">{
                newServices[svc.Name] = svc
        }</span>

        <span class="cov0" title="0">for name := range newServices </span><span class="cov0" title="0">{
                if _, exists := oldServices[name]; !exists </span><span class="cov0" title="0">{
                        servicesAdded = append(servicesAdded, name)
                }</span>
        }

        <span class="cov0" title="0">for name := range oldServices </span><span class="cov0" title="0">{
                if _, exists := newServices[name]; !exists </span><span class="cov0" title="0">{
                        servicesRemoved = append(servicesRemoved, name)
                }</span>
        }

        <span class="cov0" title="0">changes["services"] = map[string]interface{}{
                "added":   servicesAdded,
                "removed": servicesRemoved,
        }

        return changes</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package docs

import (
        "bytes"
        "fmt"
        "html/template"
        "strings"
)

// HTMLExporter exports documentation to HTML format
type HTMLExporter struct {
        template *template.Template
}

// NewHTMLExporter creates a new HTML exporter
func NewHTMLExporter() *HTMLExporter <span class="cov8" title="1">{
        tmpl := template.Must(template.New("docs").Funcs(template.FuncMap{
                "escape":     template.HTMLEscapeString,
                "markdown":   markdownToHTML,
                "anchor":     toAnchor,
                "hasContent": hasContent,
        }).Parse(htmlTemplate))

        return &amp;HTMLExporter{
                template: tmpl,
        }
}</span>

// Export exports documentation to HTML
func (e *HTMLExporter) Export(doc *Documentation) (string, error) <span class="cov8" title="1">{
        return e.ExportWithVersion(doc, "")
}</span>

// ExportWithVersion exports documentation with version info
func (e *HTMLExporter) ExportWithVersion(doc *Documentation, version string) (string, error) <span class="cov8" title="1">{
        data := struct {
                *Documentation
                Version string
        }{
                Documentation: doc,
                Version:       version,
        }

        var buf bytes.Buffer
        err := e.template.Execute(&amp;buf, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to execute template: %w", err)
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// toAnchor converts a name to an HTML anchor
func toAnchor(name string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.ReplaceAll(name, " ", "-"))
}</span>

// hasContent checks if a string has content
func hasContent(s string) bool <span class="cov8" title="1">{
        return strings.TrimSpace(s) != ""
}</span>

// markdownToHTML converts simple markdown to HTML
func markdownToHTML(text string) template.HTML <span class="cov8" title="1">{
        if text == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Simple markdown conversion
        <span class="cov8" title="1">text = template.HTMLEscapeString(text)

        // Bold
        text = strings.ReplaceAll(text, "**", "&lt;strong&gt;")

        // Code blocks
        lines := strings.Split(text, "\n")
        var result []string
        inCodeBlock := false

        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "```") </span><span class="cov8" title="1">{
                        if inCodeBlock </span><span class="cov8" title="1">{
                                result = append(result, "&lt;/code&gt;&lt;/pre&gt;")
                        }</span> else<span class="cov8" title="1"> {
                                result = append(result, "&lt;pre&gt;&lt;code&gt;")
                        }</span>
                        <span class="cov8" title="1">inCodeBlock = !inCodeBlock
                        continue</span>
                }

                <span class="cov8" title="1">if inCodeBlock </span><span class="cov8" title="1">{
                        result = append(result, line)
                }</span> else<span class="cov8" title="1"> {
                        // Inline code
                        line = strings.ReplaceAll(line, "`", "&lt;code&gt;")
                        result = append(result, "&lt;p&gt;"+line+"&lt;/p&gt;")
                }</span>
        }

        <span class="cov8" title="1">return template.HTML(strings.Join(result, "\n"))</span>
}

const htmlTemplate = `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;{{ .PackageName }} - API Documentation&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background: #2c3e50;
            color: white;
            padding: 30px 0;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        header h1 {
            margin-bottom: 10px;
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: #3498db;
            color: white;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: 600;
        }
        nav {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav h2 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        nav ul {
            list-style: none;
        }
        nav ul li {
            margin: 8px 0;
        }
        nav a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
        .content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #2c3e50;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        h3 {
            color: #34495e;
            margin: 25px 0 15px 0;
        }
        h4 {
            color: #7f8c8d;
            margin: 20px 0 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th {
            background: #ecf0f1;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #bdc3c7;
        }
        td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }
        tr:hover {
            background: #f8f9fa;
        }
        code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            font-size: 0.9em;
            color: #e74c3c;
        }
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        pre code {
            background: none;
            color: #ecf0f1;
            padding: 0;
        }
        .deprecated {
            color: #e74c3c;
            font-weight: 600;
        }
        .method-signature {
            background: #ecf0f1;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 15px 0;
            font-family: monospace;
        }
        .streaming {
            color: #9b59b6;
            font-size: 0.85em;
            font-style: italic;
        }
        .label {
            display: inline-block;
            padding: 2px 8px;
            background: #95a5a6;
            color: white;
            border-radius: 3px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .label.repeated {
            background: #3498db;
        }
        .label.optional {
            background: #f39c12;
        }
        .label.required {
            background: #e74c3c;
        }
        .search-box {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 5px;
            font-size: 1em;
            margin-bottom: 20px;
        }
        .search-box:focus {
            outline: none;
            border-color: #3498db;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;div class="container"&gt;
            &lt;h1&gt;{{ .PackageName }}&lt;/h1&gt;
            {{ if .Syntax }}
            &lt;span class="badge"&gt;{{ .Syntax }}&lt;/span&gt;
            {{ end }}
            {{ if .Version }}
            &lt;span class="badge"&gt;Version {{ .Version }}&lt;/span&gt;
            {{ end }}
        &lt;/div&gt;
    &lt;/header&gt;

    &lt;div class="container"&gt;
        &lt;nav&gt;
            &lt;h2&gt;Table of Contents&lt;/h2&gt;
            &lt;input type="text" class="search-box" placeholder="Search documentation..." id="search"&gt;
            &lt;ul&gt;
                {{ if .Services }}
                &lt;li&gt;&lt;a href="#services"&gt;Services&lt;/a&gt;&lt;/li&gt;
                {{ end }}
                {{ if .Messages }}
                &lt;li&gt;&lt;a href="#messages"&gt;Messages&lt;/a&gt;&lt;/li&gt;
                {{ end }}
                {{ if .Enums }}
                &lt;li&gt;&lt;a href="#enums"&gt;Enums&lt;/a&gt;&lt;/li&gt;
                {{ end }}
            &lt;/ul&gt;
        &lt;/nav&gt;

        &lt;div class="content"&gt;
            {{ if hasContent .Description }}
            &lt;p&gt;{{ .Description }}&lt;/p&gt;
            {{ end }}

            {{ if .Services }}
            &lt;h2 id="services"&gt;Services&lt;/h2&gt;
            {{ range .Services }}
            &lt;h3 id="{{ anchor .Name }}"&gt;{{ .Name }}&lt;/h3&gt;
            {{ if .Deprecated }}&lt;p class="deprecated"&gt;⚠️ Deprecated&lt;/p&gt;{{ end }}
            {{ if hasContent .Description }}&lt;p&gt;{{ .Description }}&lt;/p&gt;{{ end }}

            {{ if .Methods }}
            &lt;h4&gt;Methods&lt;/h4&gt;
            {{ range .Methods }}
            &lt;h4 id="{{ anchor .Name }}"&gt;{{ .Name }}&lt;/h4&gt;
            {{ if .Deprecated }}&lt;p class="deprecated"&gt;⚠️ Deprecated&lt;/p&gt;{{ end }}
            {{ if hasContent .Description }}&lt;p&gt;{{ .Description }}&lt;/p&gt;{{ end }}

            &lt;div class="method-signature"&gt;
                rpc {{ .Name }} ({{ .RequestType }}) returns ({{ .ResponseType }})
                {{ if .ClientStreaming }}{{ if .ServerStreaming }}
                &lt;span class="streaming"&gt;(bidirectional streaming)&lt;/span&gt;
                {{ else }}
                &lt;span class="streaming"&gt;(client streaming)&lt;/span&gt;
                {{ end }}{{ else }}{{ if .ServerStreaming }}
                &lt;span class="streaming"&gt;(server streaming)&lt;/span&gt;
                {{ end }}{{ end }}
            &lt;/div&gt;
            {{ end }}
            {{ end }}
            {{ end }}
            {{ end }}

            {{ if .Messages }}
            &lt;h2 id="messages"&gt;Messages&lt;/h2&gt;
            {{ range .Messages }}
            {{ template "message" . }}
            {{ end }}
            {{ end }}

            {{ if .Enums }}
            &lt;h2 id="enums"&gt;Enums&lt;/h2&gt;
            {{ range .Enums }}
            {{ template "enum" . }}
            {{ end }}
            {{ end }}
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Simple search functionality
        document.getElementById('search').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const content = document.querySelector('.content');
            const sections = content.querySelectorAll('h3, h4');

            sections.forEach(section =&gt; {
                const text = section.textContent.toLowerCase();
                const parent = section.parentElement;

                if (text.includes(searchTerm) || searchTerm === '') {
                    parent.style.display = '';
                } else {
                    parent.style.display = 'none';
                }
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

{{ define "message" }}
&lt;h3 id="{{ anchor .Name }}"&gt;{{ .Name }}&lt;/h3&gt;
{{ if .Deprecated }}&lt;p class="deprecated"&gt;⚠️ Deprecated&lt;/p&gt;{{ end }}
{{ if hasContent .Description }}&lt;p&gt;{{ .Description }}&lt;/p&gt;{{ end }}

{{ if .Fields }}
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Field&lt;/th&gt;
            &lt;th&gt;Type&lt;/th&gt;
            &lt;th&gt;Number&lt;/th&gt;
            &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{ range .Fields }}
        &lt;tr&gt;
            &lt;td&gt;
                &lt;code&gt;{{ .Name }}&lt;/code&gt;
                {{ if .Repeated }}&lt;span class="label repeated"&gt;repeated&lt;/span&gt;{{ end }}
                {{ if .Optional }}&lt;span class="label optional"&gt;optional&lt;/span&gt;{{ end }}
                {{ if .Required }}&lt;span class="label required"&gt;required&lt;/span&gt;{{ end }}
            &lt;/td&gt;
            &lt;td&gt;&lt;code&gt;{{ .Type }}&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;{{ .Number }}&lt;/td&gt;
            &lt;td&gt;
                {{ if .Deprecated }}&lt;span class="deprecated"&gt;⚠️ Deprecated&lt;/span&gt; {{ end }}
                {{ .Description }}
            &lt;/td&gt;
        &lt;/tr&gt;
        {{ end }}
    &lt;/tbody&gt;
&lt;/table&gt;
{{ end }}

{{ if .Enums }}
{{ range .Enums }}
{{ template "enum" . }}
{{ end }}
{{ end }}

{{ if .NestedTypes }}
{{ range .NestedTypes }}
{{ template "message" . }}
{{ end }}
{{ end }}
{{ end }}

{{ define "enum" }}
&lt;h3 id="{{ anchor .Name }}"&gt;{{ .Name }}&lt;/h3&gt;
{{ if .Deprecated }}&lt;p class="deprecated"&gt;⚠️ Deprecated&lt;/p&gt;{{ end }}
{{ if hasContent .Description }}&lt;p&gt;{{ .Description }}&lt;/p&gt;{{ end }}

{{ if .Values }}
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Number&lt;/th&gt;
            &lt;th&gt;Description&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{ range .Values }}
        &lt;tr&gt;
            &lt;td&gt;&lt;code&gt;{{ .Name }}&lt;/code&gt;&lt;/td&gt;
            &lt;td&gt;{{ .Number }}&lt;/td&gt;
            &lt;td&gt;
                {{ if .Deprecated }}&lt;span class="deprecated"&gt;⚠️ Deprecated&lt;/span&gt; {{ end }}
                {{ .Description }}
            &lt;/td&gt;
        &lt;/tr&gt;
        {{ end }}
    &lt;/tbody&gt;
&lt;/table&gt;
{{ end }}
{{ end }}
`
</pre>
		
		<pre class="file" id="file3" style="display: none">package docs

import (
        "fmt"
        "strings"
)

// MarkdownExporter exports documentation to Markdown format
type MarkdownExporter struct{}

// NewMarkdownExporter creates a new Markdown exporter
func NewMarkdownExporter() *MarkdownExporter <span class="cov8" title="1">{
        return &amp;MarkdownExporter{}
}</span>

// Export exports documentation to Markdown
func (e *MarkdownExporter) Export(doc *Documentation) string <span class="cov8" title="1">{
        var b strings.Builder

        // Title
        b.WriteString(fmt.Sprintf("# %s\n\n", doc.PackageName))

        // Package info
        if doc.Syntax != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("**Syntax:** `%s`\n\n", doc.Syntax))
        }</span>

        <span class="cov8" title="1">if doc.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s\n\n", doc.Description))
        }</span>

        // Table of contents
        <span class="cov8" title="1">b.WriteString("## Table of Contents\n\n")
        if len(doc.Services) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("- [Services](#services)\n")
        }</span>
        <span class="cov8" title="1">if len(doc.Messages) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("- [Messages](#messages)\n")
        }</span>
        <span class="cov8" title="1">if len(doc.Enums) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("- [Enums](#enums)\n")
        }</span>
        <span class="cov8" title="1">b.WriteString("\n")

        // Services
        if len(doc.Services) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("## Services\n\n")
                for _, svc := range doc.Services </span><span class="cov8" title="1">{
                        e.writeService(&amp;b, svc)
                }</span>
        }

        // Messages
        <span class="cov8" title="1">if len(doc.Messages) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("## Messages\n\n")
                for _, msg := range doc.Messages </span><span class="cov8" title="1">{
                        e.writeMessage(&amp;b, msg, 0)
                }</span>
        }

        // Enums
        <span class="cov8" title="1">if len(doc.Enums) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("## Enums\n\n")
                for _, enum := range doc.Enums </span><span class="cov8" title="1">{
                        e.writeEnum(&amp;b, enum)
                }</span>
        }

        <span class="cov8" title="1">return b.String()</span>
}

// writeService writes a service to markdown
func (e *MarkdownExporter) writeService(b *strings.Builder, svc *ServiceDoc) <span class="cov8" title="1">{
        b.WriteString(fmt.Sprintf("### %s\n\n", svc.Name))

        if svc.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s\n\n", svc.Description))
        }</span>

        <span class="cov8" title="1">if svc.Deprecated </span><span class="cov8" title="1">{
                b.WriteString("**⚠️ Deprecated**\n\n")
        }</span>

        // Methods
        <span class="cov8" title="1">if len(svc.Methods) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("#### Methods\n\n")
                for _, method := range svc.Methods </span><span class="cov8" title="1">{
                        e.writeMethod(b, method)
                }</span>
        }
}

// writeMethod writes a method to markdown
func (e *MarkdownExporter) writeMethod(b *strings.Builder, method *MethodDoc) <span class="cov8" title="1">{
        // Method signature
        streaming := ""
        if method.ClientStreaming &amp;&amp; method.ServerStreaming </span><span class="cov8" title="1">{
                streaming = " (bidirectional streaming)"
        }</span> else<span class="cov8" title="1"> if method.ClientStreaming </span><span class="cov8" title="1">{
                streaming = " (client streaming)"
        }</span> else<span class="cov8" title="1"> if method.ServerStreaming </span><span class="cov8" title="1">{
                streaming = " (server streaming)"
        }</span>

        <span class="cov8" title="1">b.WriteString(fmt.Sprintf("##### `%s`%s\n\n", method.Name, streaming))

        if method.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s\n\n", method.Description))
        }</span>

        <span class="cov8" title="1">if method.Deprecated </span><span class="cov8" title="1">{
                b.WriteString("**⚠️ Deprecated**\n\n")
        }</span>

        // Request/Response
        <span class="cov8" title="1">b.WriteString("```protobuf\n")
        b.WriteString(fmt.Sprintf("rpc %s (%s) returns (%s)\n",
                method.Name, method.RequestType, method.ResponseType))
        b.WriteString("```\n\n")

        if method.HTTPMethod != "" &amp;&amp; method.HTTPPath != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("**HTTP:** `%s %s`\n\n", method.HTTPMethod, method.HTTPPath))
        }</span>
}

// writeMessage writes a message to markdown
func (e *MarkdownExporter) writeMessage(b *strings.Builder, msg *MessageDoc, depth int) <span class="cov8" title="1">{
        // Message header
        prefix := strings.Repeat("#", 3+depth)
        b.WriteString(fmt.Sprintf("%s %s\n\n", prefix, msg.Name))

        if msg.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s\n\n", msg.Description))
        }</span>

        <span class="cov8" title="1">if msg.Deprecated </span><span class="cov8" title="1">{
                b.WriteString("**⚠️ Deprecated**\n\n")
        }</span>

        // Fields table
        <span class="cov8" title="1">if len(msg.Fields) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("| Field | Type | Label | Description |\n")
                b.WriteString("|-------|------|-------|-------------|\n")

                for _, field := range msg.Fields </span><span class="cov8" title="1">{
                        desc := field.Description
                        if field.Deprecated </span><span class="cov8" title="1">{
                                desc = "⚠️ **Deprecated** " + desc
                        }</span>
                        <span class="cov8" title="1">if field.OneofName != "" </span><span class="cov8" title="1">{
                                desc = fmt.Sprintf("(oneof %s) %s", field.OneofName, desc)
                        }</span>

                        <span class="cov8" title="1">label := field.Label
                        if label == "" </span><span class="cov8" title="1">{
                                label = "-"
                        }</span>

                        <span class="cov8" title="1">b.WriteString(fmt.Sprintf("| %s | `%s` | %s | %s |\n",
                                field.Name, field.Type, label, desc))</span>
                }
                <span class="cov8" title="1">b.WriteString("\n")</span>
        }

        // Nested enums
        <span class="cov8" title="1">for _, enum := range msg.Enums </span><span class="cov8" title="1">{
                e.writeEnum(b, enum)
        }</span>

        // Nested messages
        <span class="cov8" title="1">for _, nested := range msg.NestedTypes </span><span class="cov8" title="1">{
                e.writeMessage(b, nested, depth+1)
        }</span>
}

// writeEnum writes an enum to markdown
func (e *MarkdownExporter) writeEnum(b *strings.Builder, enum *EnumDoc) <span class="cov8" title="1">{
        b.WriteString(fmt.Sprintf("### %s\n\n", enum.Name))

        if enum.Description != "" </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s\n\n", enum.Description))
        }</span>

        <span class="cov8" title="1">if enum.Deprecated </span><span class="cov8" title="1">{
                b.WriteString("**⚠️ Deprecated**\n\n")
        }</span>

        // Values table
        <span class="cov8" title="1">if len(enum.Values) &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("| Name | Number | Description |\n")
                b.WriteString("|------|--------|-------------|\n")

                for _, value := range enum.Values </span><span class="cov8" title="1">{
                        desc := value.Description
                        if value.Deprecated </span><span class="cov8" title="1">{
                                desc = "⚠️ **Deprecated** " + desc
                        }</span>

                        <span class="cov8" title="1">b.WriteString(fmt.Sprintf("| %s | %d | %s |\n",
                                value.Name, value.Number, desc))</span>
                }
                <span class="cov8" title="1">b.WriteString("\n")</span>
        }
}

// ExportWithVersion exports documentation with version information
func (e *MarkdownExporter) ExportWithVersion(doc *Documentation, version string) string <span class="cov8" title="1">{
        var b strings.Builder

        // Version header
        b.WriteString(fmt.Sprintf("# %s (Version %s)\n\n", doc.PackageName, version))

        // Add rest of documentation
        exported := e.Export(doc)
        // Skip the first line (title) since we already added version header
        lines := strings.Split(exported, "\n")
        if len(lines) &gt; 2 </span><span class="cov8" title="1">{
                b.WriteString(strings.Join(lines[2:], "\n"))
        }</span>

        <span class="cov8" title="1">return b.String()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
